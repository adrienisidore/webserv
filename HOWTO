nc localhost 54000 : permet d’envoyer des messages et de tester le serveur echo
sans navigateur ni programme client spécifique. Ouvre une connexion TCP reçu par mon serveur

HOWTO 1

inet_pton non autorisée. Au lieu de faire inet_pton(AF_INET, "0.0.0.0", &hint.sin_addr);, on fait 

// struct addrinfo de <netdb.h>, permet de spécifier les critères pour retourner une adresse compatible
// à notre socket. getaddrinfo() retournera toutes les adresses compatibles dans res sous forme de liste
//chainée.
// struct addrinfo
// {
//     int              ai_flags;     // options : AI_PASSIVE, AI_CANONNAME…
//     int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC
//     int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM…
//     int              ai_protocol;  // IPPROTO_TCP, IPPROTO_UDP…
//     socklen_t        ai_addrlen;   // taille de ai_addr
//     struct sockaddr *ai_addr;      // pointeur vers l’adresse (sockaddr_in ou sockaddr_in6)
//     char            *ai_canonname; // nom canonique (facultatif)
//     struct addrinfo *ai_next;      // pointeur vers l’élément suivant de la liste
// };

struct addrinfo hints{}, *res;//{} permet de mettre tous les champs à 0, comme memset(&hints, 0, sizeof hints)
hints.ai_family = AF_INET;// IPv4
hints.ai_socktype = SOCK_STREAM;// TCP
hints.ai_flags = AI_PASSIVE; // adresse pour un serveur qui écoute

getaddrinfo(NULL, "54000", &hints, &res); // NULL = 0.0.0.0:54000, le serveur accepte les connexions
//sur toutes les IP à condition que le port soit 54000

bind(listening, res->ai_addr, res->ai_addrlen);//res->ai_addr : la première adresse dispo
//On spécifie la taille car toutes les adresses IP n'ont pas la même taille (ex IPv6)
freeaddrinfo(res);


HOWTO 2
//getnameinfo convertit l’adresse du client (sockaddr) en nom d’hôte et port lisibles qu'il stock
//dans host[NI_MAXHOST] et service[NI_MAXSERV] ? Et donc si ne peux ni utiliser getnameinfo ni inet_ntop
//alors je dois faire la conversion moi même.

// Pour une IPv4 je peux faire par exemple :
unsigned char *ip = (unsigned char *)&client.sin_addr.s_addr;
std::cout << (int)ip[0] << '.'
          << (int)ip[1] << '.'
          << (int)ip[2] << '.'
          << (int)ip[3]
          << " connected on port " << ntohs(client.sin_port) << std::endl;





--------------------------------
- 1) Le programme prend un fichier de configuration en argument, et a un default path.
- 2) webserv ne doit pas execve() un autre serveur web.
- 3) webserv peut traiter d’autres clients même si un client nenvoie rien.
- 4) poll(), select(), epoll_wait() permettent de surveiller plusieurs sockets en même temps.
une seule boucle de surveillance pour tous les clients, y compris le socket d'écoute (listening).
Lacceptation des nouveaux clients (accept) et communication avec les clients existants (recv/send)
se font dans le même mécanisme. Le serveur reste disponible même avec beaucoup de clients simultanés
- 5) Les macros FD_SET, FD_CLR, FD_ISSET, FD_ZERO sont très utiles pour utiliser plusieurs sockets
- 6) Le serveur doit gérer les timeouts ou I/O non-bloquantes pour éviter qu’un client inactif bloque tout le serveur.
- 7) Les réponses et en-têtes de ton serveur peuvent être comparées à NGINX pour vérifier conformité HTTP/1.1
- 8) Faire une page d'erreur "404 Not Found". Les autres codes HTTP retournés doivent être précis
- 9) fork() ne doit être utilisé que pour lancer des exécutables CGI (pages dynamiques), pas pour gérer les connexions
normales du serveur
- 10) Le serveur doit pouvoir accepter des connexions sur différents ports configurables (ex. 80, 8080...)


